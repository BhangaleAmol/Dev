# Databricks notebook source
# MAGIC %run ../SHARED/bootstrap

# COMMAND ----------

# Get parameters
dbutils.widgets.text("source_folder", "","")
sourceFolder = getArgument("source_folder")
sourceFolder = '/datalake/EBS/raw_data/delta_data' if sourceFolder == '' else sourceFolder

dbutils.widgets.text("target_folder", "","")
targetFolder = getArgument("target_folder")
targetFolder = '/datalake/EBS/stage_data' if targetFolder == '' else targetFolder

dbutils.widgets.text("table_name", "","")
tableName = getArgument("table_name")
tableName = 'W_GL_ACCOUNT_D' if tableName == '' else tableName

# COMMAND ----------

# Create paths
sourceFolderUrl = DATALAKE_ENDPOINT  + sourceFolder + '/'
sourceFolderDomainValuesUrl = DATALAKE_ENDPOINT + '/datalake/EBS/raw_data/domain_values/'
targetFileUrl = DATALAKE_ENDPOINT +  targetFolder + '/' + tableName + '.par'

print(sourceFolderUrl)
print(sourceFolderDomainValuesUrl)
print(targetFileUrl)

# COMMAND ----------

# INCREMENTAL DATASET
# Guy 2020/06/10 : no additional incremental logic needed
sourceFileUrl = sourceFolderUrl + 'apps.gl_code_combinations.par'
GL_CODE_COMBINATIONS = spark.read.parquet(sourceFileUrl)
GL_CODE_COMBINATIONS.createOrReplaceTempView("GL_CODE_COMBINATIONS")

# STATIC CSV
sourceFileUrl = sourceFolderDomainValuesUrl + 'W_GLACCT_SEG_CONFIG_TMP.csv'
W_GLACCT_SEG_CONFIG_TMP = spark.read.format("csv").option("header", "true").load(sourceFileUrl)
W_GLACCT_SEG_CONFIG_TMP.createOrReplaceTempView("W_GLACCT_SEG_CONFIG_TMP")

sourceFileUrl = sourceFolderDomainValuesUrl + 'W_ORA_GROUP_ACCOUNT_NUM_D_TMP.csv'
W_ORA_GROUP_ACCOUNT_NUM_D_TMP = spark.read.format("csv").option("header", "true").load(sourceFileUrl)
W_ORA_GROUP_ACCOUNT_NUM_D_TMP.createOrReplaceTempView("W_ORA_GROUP_ACCOUNT_NUM_D_TMP")

sourceFileUrl = sourceFolderDomainValuesUrl + 'LKP_GROUP_ACCOUNT_NUM.csv'
LKP_GROUP_ACCOUNT_NUM = spark.read.format("csv").option("header", "true").load(sourceFileUrl)
LKP_GROUP_ACCOUNT_NUM.createOrReplaceTempView("LKP_GROUP_ACCOUNT_NUM")

# COMMAND ----------

W_GL_ACCOUNT_D = spark.sql("""
  SELECT
    INT(GL_CODE_COMBINATIONS.CODE_COMBINATION_ID) INTEGRATION_ID, 
    GL_CODE_COMBINATIONS.LAST_UPDATE_DATE CREATED_ON_DT, 
    GL_CODE_COMBINATIONS.LAST_UPDATE_DATE CHANGED_ON_DT, 
    GL_CODE_COMBINATIONS.LAST_UPDATED_BY CREATED_BY_ID,
	GL_CODE_COMBINATIONS.LAST_UPDATED_BY CHANGED_BY_ID,
	DATE_FORMAT(CURRENT_TIMESTAMP,'yyyy-MM-dd HH:mm:ss.SSS') INSERT_DT,             
    DATE_FORMAT(CURRENT_TIMESTAMP,'yyyy-MM-dd HH:mm:ss.SSS') UPDATE_DT,
    'EBS' DATASOURCE_NUM_ID,
    STRING(DATE_FORMAT(current_timestamp(),'yyyyMMddHHmmssSSS')) LOAD_BATCH_ID,
    GL_CODE_COMBINATIONS.SEGMENT2 GL_ACCOUNT_NUM,
	GL_CODE_COMBINATIONS.SEGMENT2 GL_ACCOUNT_NAME,    
    CONCAT(INT(COALESCE(FND_ID_FLEX_SEGMENTS.FLEX_VALUE_SET_ID,'')),'-', INT(COALESCE(GL_CODE_COMBINATIONS.SEGMENT2,''))) GL_ACCOUNT_DESC,
    CASE 
       WHEN lkp_group_account_num.GL_ACCT_CAT_CODE IS NULL THEN 'BS'
       ELSE lkp_group_account_num.GL_ACCT_CAT_CODE 
    END GL_ACCOUNT_CAT_CODE,
    CASE 
      WHEN lkp_group_account_num.GL_ACCT_CAT_CODE IS NULL THEN 'Balance sheet' 
      ELSE 'Profit & Loss Account' 				
    END GL_ACCOUNT_CAT_NAME,
    GL_CODE_COMBINATIONS.SEGMENT1 ACCOUNT_SEG1_CODE,
    CONCAT(
      INT(COALESCE(GL_CODE_COMBINATIONS.CHART_OF_ACCOUNTS_ID,'')),'-', 
      COALESCE('SEGMENT1',''),'-',
      COALESCE(GL_CODE_COMBINATIONS.SEGMENT1,'')
    ) ACCOUNT_SEG1_NAME,
    W_GLACCT_SEG_CONFIG_TMP.SEG1_ATTRIB ACCOUNT_SEG1_ATTRIB,
    GL_CODE_COMBINATIONS.SEGMENT2 ACCOUNT_SEG2_CODE,
    CONCAT(
       INT(COALESCE(GL_CODE_COMBINATIONS.CHART_OF_ACCOUNTS_ID,'')),'-',
       COALESCE('SEGMENT2',''),'-',
       COALESCE(GL_CODE_COMBINATIONS.SEGMENT2,'')
    ) ACCOUNT_SEG2_NAME,
    W_GLACCT_SEG_CONFIG_TMP.SEG2_ATTRIB ACCOUNT_SEG2_ATTRIB,
    GL_CODE_COMBINATIONS.SEGMENT3 ACCOUNT_SEG3_CODE,
    CONCAT(
      INT(COALESCE(GL_CODE_COMBINATIONS.CHART_OF_ACCOUNTS_ID,'')),'-',
      COALESCE('SEGMENT3',''),'-' ,
      COALESCE(GL_CODE_COMBINATIONS.SEGMENT3,'')
    ) ACCOUNT_SEG3_NAME,
    W_GLACCT_SEG_CONFIG_TMP.SEG3_ATTRIB ACCOUNT_SEG3_ATTRIB,
    GL_CODE_COMBINATIONS.SEGMENT4 ACCOUNT_SEG4_CODE,
    CONCAT(
      INT(COALESCE(GL_CODE_COMBINATIONS.CHART_OF_ACCOUNTS_ID,'')),'-',
      COALESCE('SEGMENT4',''),'-',
      COALESCE(GL_CODE_COMBINATIONS.SEGMENT4,'')
    ) ACCOUNT_SEG4_NAME,
    W_GLACCT_SEG_CONFIG_TMP.SEG4_ATTRIB ACCOUNT_SEG4_ATTRIB,
    GL_CODE_COMBINATIONS.SEGMENT5 ACCOUNT_SEG5_CODE,
    CONCAT(
      INT(COALESCE(GL_CODE_COMBINATIONS.CHART_OF_ACCOUNTS_ID,'')),'-',
      COALESCE('SEGMENT5',''),'-',
      COALESCE(GL_CODE_COMBINATIONS.SEGMENT5,'')
    ) ACCOUNT_SEG5_NAME,
    W_GLACCT_SEG_CONFIG_TMP.SEG5_ATTRIB ACCOUNT_SEG5_ATTRIB,
    GL_CODE_COMBINATIONS.SEGMENT6 ACCOUNT_SEG6_CODE,
    CONCAT(
      INT(COALESCE(GL_CODE_COMBINATIONS.CHART_OF_ACCOUNTS_ID,'')),'-',
      COALESCE('SEGMENT6',''),'-',
      COALESCE( GL_CODE_COMBINATIONS.SEGMENT6,'')
    ) ACCOUNT_SEG6_NAME,
    W_GLACCT_SEG_CONFIG_TMP.SEG6_ATTRIB ACCOUNT_SEG6_ATTRIB,
    GL_CODE_COMBINATIONS.SEGMENT7 ACCOUNT_SEG7_CODE,
    CONCAT(
      INT(COALESCE(GL_CODE_COMBINATIONS.CHART_OF_ACCOUNTS_ID,'')),'-',
      COALESCE('SEGMENT7',''),'-',
      COALESCE(GL_CODE_COMBINATIONS.SEGMENT7,'')
    ) ACCOUNT_SEG7_NAME,
    W_GLACCT_SEG_CONFIG_TMP.SEG7_ATTRIB ACCOUNT_SEG7_ATTRIB,
    'Y' ACTIVE_FLG,
    'N' DELETE_FLG  
  FROM GL_CODE_COMBINATIONS  
  INNER JOIN FND_ID_FLEX_STRUCTURES ON 
    GL_CODE_COMBINATIONS.CHART_OF_ACCOUNTS_ID=FND_ID_FLEX_STRUCTURES.ID_FLEX_NUM
    AND FND_ID_FLEX_STRUCTURES.ID_FLEX_CODE = 'GL#' 
    AND FND_ID_FLEX_STRUCTURES.APPLICATION_ID = 101 AND FND_ID_FLEX_STRUCTURES.ENABLED_FLAG = 'Y'
  INNER JOIN FND_SEGMENT_ATTRIBUTE_VALUES ON
    GL_CODE_COMBINATIONS.CHART_OF_ACCOUNTS_ID = FND_SEGMENT_ATTRIBUTE_VALUES.ID_FLEX_NUM
    AND FND_SEGMENT_ATTRIBUTE_VALUES.APPLICATION_ID = 101 
    AND FND_SEGMENT_ATTRIBUTE_VALUES.ID_FLEX_CODE = 'GL#' 
    AND FND_SEGMENT_ATTRIBUTE_VALUES.SEGMENT_ATTRIBUTE_TYPE = 'GL_ACCOUNT' 
    AND FND_SEGMENT_ATTRIBUTE_VALUES.ATTRIBUTE_VALUE = 'Y'
  INNER JOIN FND_SEGMENT_ATTRIBUTE_VALUES FND_SEGMENT_ATTRIBUTE_VALUES2 ON
    GL_CODE_COMBINATIONS.CHART_OF_ACCOUNTS_ID = FND_SEGMENT_ATTRIBUTE_VALUES2.ID_FLEX_NUM 
    AND FND_SEGMENT_ATTRIBUTE_VALUES2.APPLICATION_ID = 101 
    AND FND_SEGMENT_ATTRIBUTE_VALUES2.ID_FLEX_CODE = 'GL#' 
    AND FND_SEGMENT_ATTRIBUTE_VALUES2.SEGMENT_ATTRIBUTE_TYPE = 'GL_BALANCING' 
    AND FND_SEGMENT_ATTRIBUTE_VALUES2.ATTRIBUTE_VALUE = 'Y'
  INNER JOIN FND_ID_FLEX_SEGMENTS ON
     GL_CODE_COMBINATIONS.CHART_OF_ACCOUNTS_ID=FND_ID_FLEX_SEGMENTS.ID_FLEX_NUM 
     AND FND_ID_FLEX_SEGMENTS.ID_FLEX_CODE = 'GL#'
     AND FND_ID_FLEX_SEGMENTS.APPLICATION_ID = 101
     AND FND_ID_FLEX_SEGMENTS.APPLICATION_COLUMN_NAME = FND_SEGMENT_ATTRIBUTE_VALUES.APPLICATION_COLUMN_NAME
  INNER JOIN FND_ID_FLEX_SEGMENTS FND_ID_FLEX_SEGMENTS2 ON 
     GL_CODE_COMBINATIONS.CHART_OF_ACCOUNTS_ID = FND_ID_FLEX_SEGMENTS2.ID_FLEX_NUM and FND_ID_FLEX_SEGMENTS2.ID_FLEX_CODE = 'GL#' 
     AND FND_ID_FLEX_SEGMENTS2.APPLICATION_ID = 101
     AND FND_ID_FLEX_SEGMENTS2.APPLICATION_COLUMN_NAME = FND_SEGMENT_ATTRIBUTE_VALUES2.APPLICATION_COLUMN_NAME
  LEFT JOIN FND_SEGMENT_ATTRIBUTE_VALUES FND_SEGMENT_ATTRIBUTE_VALUES1 ON
     GL_CODE_COMBINATIONS.CHART_OF_ACCOUNTS_ID =  FND_SEGMENT_ATTRIBUTE_VALUES1.ID_FLEX_NUM 
     AND FND_SEGMENT_ATTRIBUTE_VALUES1.APPLICATION_ID = 101 
     AND FND_SEGMENT_ATTRIBUTE_VALUES1.ID_FLEX_CODE = 'GL#' 
     AND FND_SEGMENT_ATTRIBUTE_VALUES1.SEGMENT_ATTRIBUTE_TYPE = 'FA_COST_CTR' 
     AND FND_SEGMENT_ATTRIBUTE_VALUES1.ATTRIBUTE_VALUE = 'Y'
  LEFT JOIN W_GLACCT_SEG_CONFIG_TMP ON GL_CODE_COMBINATIONS.CHART_OF_ACCOUNTS_ID = W_GLACCT_SEG_CONFIG_TMP.CHARTFIELD_GROUP_ID
  LEFT JOIN  W_ORA_GROUP_ACCOUNT_NUM_D_TMP ON 
     W_ORA_GROUP_ACCOUNT_NUM_D_TMP.CHART_OF_ACCOUNTS_ID = GL_CODE_COMBINATIONS.CHART_OF_ACCOUNTS_ID  
     AND FROM_ACCT_NUM <= GL_CODE_COMBINATIONS.SEGMENT2 
     AND TO_ACCT_NUM >= GL_CODE_COMBINATIONS.SEGMENT2 
     AND GL_CODE_COMBINATIONS.SEGMENT1 >= W_ORA_GROUP_ACCOUNT_NUM_D_TMP.FROM_SEG1 
     AND GL_CODE_COMBINATIONS.SEGMENT1 <= W_ORA_GROUP_ACCOUNT_NUM_D_TMP.TO_SEG1
  LEFT JOIN LKP_GROUP_ACCOUNT_NUM ON LKP_GROUP_ACCOUNT_NUM.GROUP_ACCT_NUM = W_ORA_GROUP_ACCOUNT_NUM_D_TMP.GROUP_ACCT_NUM   
""")

W_GL_ACCOUNT_D.cache()
W_GL_ACCOUNT_D.count()

# COMMAND ----------

count = W_GL_ACCOUNT_D.select("INTEGRATION_ID").count()
countDistinct = W_GL_ACCOUNT_D.select("INTEGRATION_ID").distinct().count()

print(count)
print(countDistinct)

if(count != countDistinct):
  message = 'Mismatch in count of total records ({0}) and distinct count of primary keys ({1}) in {2} '.format(count, countDistinct, tableName)
  raise Exception(message)

# COMMAND ----------

W_GL_ACCOUNT_D.coalesce(10).write.format("parquet").mode("overwrite").save(targetFileUrl)

# COMMAND ----------

GL_CODE_COMBINATIONS.unpersist()
W_GL_ACCOUNT_D.unpersist()
